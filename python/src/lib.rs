use pyo3::prelude::*;

#[pymodule(name = "mushi")]
pub mod export {
    use std::{
        fmt,
        sync::{
            Arc, LazyLock,
            atomic::{AtomicBool, Ordering},
        },
        time::Duration,
    };

    use mushi::{
        AllowConnection, CertificateError, SigScheme, SubjectPublicKeyInfoDer, UnixTime,
        quinn::congestion::{BbrConfig, ControllerFactory, CubicConfig, NewRenoConfig},
        rcgen,
    };
    use pyo3::prelude::*;

    use crate::error::*;

    static SETUP: LazyLock<()> = LazyLock::new(mushi::install_crypto_provider);

    const SUPPORTED_SIGSCHEMES: &[SigScheme] = &[
        mushi::SIGSCHEME_ED25519,
        mushi::SIGSCHEME_ECDSA256,
        mushi::SIGSCHEME_ECDSA384,
    ];

    #[pyclass]
    #[derive(Debug, Clone)]
    pub struct EndpointKey(mushi::EndpointKey);

    #[pymethods]
    impl EndpointKey {
        #[new]
        fn new(private_key_pem: String) -> BResult<Self> {
            let kp = rcgen::KeyPair::from_pem(&private_key_pem)?;

            for scheme in SUPPORTED_SIGSCHEMES {
                if kp.is_compatible(scheme.1) {
                    return Ok(Self(mushi::EndpointKey::load(kp, *scheme)));
                }
            }

            Err(BError::UnsupportedKeyType(
                    format!("{:?}", kp.algorithm()),
            ))
        }

        fn private_key_pem(&self) -> String {
            self.0.serialize_pem()
        }

        fn public_key_pem(&self) -> String {
            self.0.public_key_pem()
        }

        fn __str__(&self) -> String {
            format!("EndpointKey type={:?}", self.0.algorithm())
        }

        /// The validity of certificates generated by this key in seconds.
        #[getter]
        pub fn get_validity(&self) -> u32 {
            self.0.validity.whole_seconds().max(0).try_into().unwrap()
        }

        /// Set the validity of certificates generated by this key in seconds.
        ///
        /// Note that changing the validity of a key once it's used in an Endpoint does nothing.
        #[setter]
        pub fn set_validity(&mut self, seconds: u32) {
            self.0.validity = Duration::from_secs(seconds as _).try_into().unwrap();
        }

        /// Generate a certificate for this key.
        ///
        /// This is primarily used internally, but exposed for convenience if you're implementing the
        /// transport yourself and don't want to bother making certificates correctly.
        ///
        /// Returns the PEM-encoded certificate.
        fn make_certificate(&self) -> BResult<String> {
            Ok(self.0.make_certificate()?.pem())
        }

        #[staticmethod]
        fn generate() -> BResult<Self> {
            Ok(Self(mushi::EndpointKey::generate()?))
        }

        #[staticmethod]
        fn generate_for(scheme: String) -> BResult<Self> {
            let scheme = match scheme.as_str() {
                "ed25519" => mushi::SIGSCHEME_ED25519,
                "ecdsa256" => mushi::SIGSCHEME_ECDSA256,
                "ecdsa384" => mushi::SIGSCHEME_ECDSA384,
                unk => return Err(BError::UnsupportedKeyType(unk.to_string())),
            };

            Ok(Self(mushi::EndpointKey::generate_for(scheme)?))
        }
    }

    #[pyclass]
    #[derive(Debug, Clone)]
    pub struct Allower(Arc<AllowerImpl>);

    #[derive(Debug)]
    pub struct AllowerImpl {
        allower: Py<PyAny>,
        client_auth: bool,
    }

    impl AllowConnection for AllowerImpl {
        fn allow_public_key(
            &self,
            key: SubjectPublicKeyInfoDer<'_>,
            now: UnixTime,
        ) -> std::result::Result<(), CertificateError> {
            let ret = Arc::new(AtomicBool::new(false));
            /*
            self.allower.call_with_return_value(
                (Buffer::from(&*key), now.as_secs() as _),
                ThreadsafeFunctionCallMode::Blocking,
                {
                    let ret = ret.clone();
                    move |value: bool| {
                        ret.store(value, Ordering::SeqCst);
                        Ok(())
                    }
                },
            );
            */
            if ret.load(Ordering::SeqCst) {
                Ok(())
            } else {
                Err(CertificateError::ApplicationVerificationFailure)
            }
        }

        fn require_client_auth(&self) -> bool {
            self.client_auth
        }
    }

    #[pymethods]
    impl Allower {
        #[new]
        fn new(allow_public_key: &Bound<'_, PyAny>, require_client_auth: Option<bool>) -> BResult<Self> {
            if !allow_public_key.is_callable() {
                return Err(BError::NotCallable("allow_public_key"));
            }

            let client_auth = require_client_auth.unwrap_or(true);
            Ok(Self(Arc::new(AllowerImpl {
                allower: allow_public_key.clone().unbind(),
                client_auth,
            })))
        }
    }
}

mod error {
    use pyo3::PyErr;

    pub(crate) type BResult<T> = Result<T, BError>;

    #[derive(Debug, thiserror::Error)]
    pub(crate) enum BError {
        #[error("key: {0}")]
        RcGen(#[from] mushi::rcgen::Error),

        #[error("key: failed to make certificate")]
        Certificate,

        #[error("key: unsupported type {0:?}")]
        UnsupportedKeyType(String),

        #[error("argument is not a callable: {0}")]
        NotCallable(&'static str),
    }

    impl From<BError> for PyErr {
        fn from(err: BError) -> Self {
            use pyo3::exceptions::*;
            match err {
                e @ BError::NotCallable(_) => PyTypeError::new_err(e.to_string()),
                e => PyValueError::new_err(e.to_string()),
            }
        }
    }
}
